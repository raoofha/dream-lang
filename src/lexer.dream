def- line 1
def- column 0
def- i 0

defn tokenize (code)
  set! tokens []
  (read)
  (readLine)
  readBlock {:value [] :type "Program" :loc {}}

defn- readToken ()
  while (= ch " ") (read)
  switch ch
    "\n" (readNewline)
    "\"" (readString)
    #"#" (readDispatch)
    "(" (readGroup "List" ")")
    "[" (readGroup "Array" "]")
    "{" (readGroup "Map" "}")
    else (readSymbol)

defn- readLine ()
  def ll (readToken)
  if !ll
    set! l nil
    return nil
  def token {:value [] :type "Line" :loc ll.loc}
  while (and ll (!= ll.type "Newline"))
    token.value.push ll
    set! ll (readToken)
  #if (= token.value.length 1)
  #  set! token (aget token.value 0)
  if ll
    set! token.loc.end ll.loc.end
  else
    set! ll (aget token.value (- token.value.length 1))
    set! token.loc.end ll.loc.end
  if (= token.value.length 0)
    return nil
  set! l token
  token


defn- readBlock (token)
  return nil if !l
  #def indent (- l.loc.start.column 1)
  def indent l.loc.start.column
  while l
    if (< l.loc.start.column indent) break
    else if (> l.loc.start.column indent)
      readBlock previous-l
    else
      token.value.push l
      set! previous-l l
      (readLine)
  if l
    set! token.loc.end l.loc.end
  else
    set! token.loc.end previous-l.loc.end
  token
  

defn- readGroup (type closeSym)
  def token {:value [] :type type :loc {:start {:line line :column column}}}
  read()
  while (!= ch closeSym)
    if (= ch nil)
      throw (js.Error. (+ "EOF while reading at line:" token.loc.start.line " column:" token.loc.start.column))
    def t (readToken)
    token.value.push t if (and t (!in t SPECIAL_CHARS) (!= t.type "Newline"))
  set! token.loc.end {:line line :column column}
  (read)
  token

defn- readSymbol ()
  def token {:value "" :type "Symbol" :loc {:start {:line line :column column}}}
  if (in ch SPECIAL_CHARS)
    set! token.value ch
    set! token.loc.end {:line line :column column}
    return token
  while (!in ch SPECIAL_CHARS)
    if (= ch "\\") (read)
    if (= ch "\n")
      if (= token.value.length 0)
        set! token.value "\\"
      else
        (unread)
      break
    += token.value ch
    (read)
  #(unread) if (= ch "\n")
  (unread)
  set! token.loc.end {:line line :column column}
  (read)
  if (= token.value "")
    nil
  else
    token
  
defn- readDispatch ()
  (read)
  switch ch
    #when " " "!" then (readComment) ; return token
    "\""
      set! token (readString)
      set! token.type "RegExp"
      token
    else
      (readComment)
      #throw (js.Error. "dispatch not defined")
defn- readComment ()
  def token {:value "" :type "Comment" :loc {:start {:line line :column column}}}
  while (!in ch ["\n" nil]) (read)
  (unread)
  set! token.loc.end {:line line :column column}
  token
defn- readNewline ()
  def token
  while (in ch [" " "\n"])
    while (= (read) "\n")
    set! token {:value "" :type "Newline" :loc {:start {:line line :column column}}}
    while (= ch " ")
      += token.value ch
      (read)
  (unread)
  set! token.loc.end {:line line :column column}
  (read)
  token
defn- readString ()
  def token {:value "" :type "String" :loc {:start {:line line :column column}}}
  while (!= (read) "\"")
    throw (js.Error. "EOF while reading") if !ch
    if (= ch "\\")
      (read)
      throw (js.Error. "EOF while reading") if !ch
      switch ch
        when "t"
          += token.value "\t"
        when "n"
          += token.value "\n"
        when "f"
          += token.value "\f"
        when "b"
          += token.value "\b"
        when "r"
          += token.value "\r"
        when "\"" "\\"
          += token.value ch
        else
          if (or (= ch "u") (Util.isDigit ch))
            += token.value (readUnicodeChar)
          else
            throw (js.Error. (+ "Unsupported escape character: \\" ch))
    else
      += token.value ch
  set! token.loc.end {:line line :column column}
  (read)
  token

defn- read ()
  if (= i code.length)
    set! ch nil
    set! column 0
    return nil
  set! ch (aget code i)
  i++
  if (= ch "\n")
    set! last-line-column column
    line++
    set! column 0
  else
    column++
  ch
defn- unread ()
  if (!= i 0)
    i--
    if (= column 0)
      line--
      set! column last-line-column
    else
      column--

def SPECIAL_CHARS ["(" ")" "[" "]" "{" "}" " " "\n" nil]
